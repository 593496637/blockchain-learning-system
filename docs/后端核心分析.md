# 后端核心代码分析

## 1. Blockchain 类核心实现 (blockchain.ts)

### 1.1 类结构和数据存储

```typescript
export class Blockchain {
  private chain: Block[] = [];                    // 主链：存储所有区块
  private pendingTransactions: Transaction[] = []; // 交易池：待打包交易
  private users: Map<string, User> = new Map();    // 用户账本：地址->用户信息
  private miners: Map<string, Miner> = new Map();  // 矿工注册表：地址->矿工信息
  
  // 系统参数配置
  private config: SystemConfig = {
    blockReward: 10,              // 挖矿奖励
    minFee: 0.1,                 // 最小交易费
    difficulty: 4,               // 挖矿难度（哈希前缀零的个数）
    maxTransactionsPerBlock: 10  // 每个区块最大交易数
  };
}
```

**设计亮点：**
- 使用 Map 结构实现 O(1) 查找性能
- 配置参数集中管理，便于调整
- 内存存储简化实现，专注核心逻辑

### 1.2 核心算法实现

#### 哈希计算算法
```typescript
private calculateHash(block: Block): string {
  // 将区块关键信息串联
  const data = block.index + 
               block.previousHash + 
               block.timestamp + 
               JSON.stringify(block.transactions) + 
               block.nonce + 
               block.miner;
  
  // 使用 SHA-256 生成哈希
  return crypto.createHash('sha256').update(data).digest('hex');
}
```

**技术要点：**
- 包含所有影响区块唯一性的字段
- nonce 字段支持工作量证明
- JSON序列化确保交易数据完整性

#### 工作量证明挖矿
```typescript
// 核心挖矿循环
while (true) {
  newBlock.hash = this.calculateHash(newBlock);
  
  // 检查是否满足难度要求
  if (newBlock.hash.substring(0, this.config.difficulty) === 
      '0'.repeat(this.config.difficulty)) {
    break;  // 找到有效哈希，挖矿成功
  }
  
  newBlock.nonce++;  // 增加随机数重试
}
```

**工作原理：**
1. 不断调整 nonce 值
2. 计算新的区块哈希
3. 检查哈希是否以指定数量的零开头
4. 难度越高，找到有效哈希的概率越低

### 1.3 交易处理机制

#### 交易创建和验证
```typescript
createTransaction(from: string, to: string, amount: number): string | null {
  const sender = this.users.get(from);
  const receiver = this.users.get(to);

  // 1. 验证用户存在性
  if (!sender || !receiver) {
    return null;
  }

  // 2. 计算总费用（转账金额 + 手续费）
  const totalCost = amount + this.config.minFee;
  
  // 3. 验证发送方余额
  if (sender.balance < totalCost) {
    return null;
  }

  // 4. 创建交易对象
  const transaction: Transaction = {
    id: uuidv4(),
    from, to, amount,
    fee: this.config.minFee,
    timestamp: Date.now(),
    status: 'pending'
  };

  // 5. 加入交易池等待打包
  this.pendingTransactions.push(transaction);
  return transaction.id;
}
```

#### 交易执行（在挖矿时）
```typescript
private validateAndProcessTransaction(transaction: Transaction): boolean {
  const sender = this.users.get(transaction.from);
  const receiver = this.users.get(transaction.to);

  if (!sender || !receiver) return false;

  const totalCost = transaction.amount + transaction.fee;
  if (sender.balance < totalCost) return false;

  // 实际执行转账
  sender.balance -= totalCost;           // 扣除发送方余额
  receiver.balance += transaction.amount; // 增加接收方余额
  transaction.status = 'confirmed';       // 标记交易已确认

  return true;
}
```

### 1.4 挖矿完整流程

```typescript
mineBlock(minerAddress: string): Block | null {
  // 1. 验证矿工有效性
  const miner = this.miners.get(minerAddress);
  if (!miner || !miner.isActive) return null;

  // 2. 从交易池选择交易（最多配置的最大数量）
  const transactionsToMine = this.pendingTransactions
    .slice(0, this.config.maxTransactionsPerBlock);

  if (transactionsToMine.length === 0) return null;

  // 3. 验证并处理选中的交易
  const validTransactions: Transaction[] = [];
  for (const tx of transactionsToMine) {
    if (this.validateAndProcessTransaction(tx)) {
      validTransactions.push(tx);
    }
  }

  // 4. 创建新区块
  const newBlock: Block = {
    index: this.chain.length,
    timestamp: Date.now(),
    transactions: validTransactions,
    previousHash: this.getLatestBlock().hash,
    hash: '',
    nonce: 0,
    miner: minerAddress,
    reward: this.config.blockReward
  };

  // 5. 执行工作量证明挖矿
  const startTime = Date.now();
  while (true) {
    newBlock.hash = this.calculateHash(newBlock);
    if (newBlock.hash.substring(0, this.config.difficulty) === 
        '0'.repeat(this.config.difficulty)) {
      break;
    }
    newBlock.nonce++;
  }

  // 6. 将新区块加入链条
  this.chain.push(newBlock);

  // 7. 奖励矿工
  this.rewardMiner(minerAddress, newBlock.reward, validTransactions);

  // 8. 从交易池移除已处理的交易
  this.pendingTransactions = this.pendingTransactions
    .filter(tx => !validTransactions.find(vtx => vtx.id === tx.id));

  return newBlock;
}
```

## 2. Express API 服务器 (index.ts)

### 2.1 服务器初始化

```typescript
const app = express();
const blockchain = new Blockchain();  // 创建区块链实例

// 中间件配置
app.use(cors());                      // 跨域支持
app.use(express.json());              // JSON解析
app.use((req, res, next) => {         // 请求日志
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});
```

### 2.2 API 设计模式

#### 统一响应格式
```typescript
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
}
```

#### 错误处理模式
```typescript
app.post('/api/users', (req, res) => {
  try {
    const { name } = req.body;
    const user = blockchain.createUser(name);
    
    const response: ApiResponse = {
      success: true,
      data: user,
      message: '用户创建成功'
    };
    
    res.json(response);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: '创建用户失败',
      message: error instanceof Error ? error.message : '未知错误'
    });
  }
});
```

### 2.3 RESTful API 设计

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| POST | `/api/users` | 创建用户 | 生成新的钱包地址 |
| GET | `/api/users` | 用户列表 | 获取所有用户 |
| GET | `/api/users/:address` | 用户详情 | 包含交易历史 |
| POST | `/api/tokens/allocate` | 分配代币 | 管理员功能 |
| POST | `/api/transactions` | 创建交易 | 发起转账 |
| GET | `/api/transactions/pending` | 交易池 | 待处理交易 |
| POST | `/api/miners` | 注册矿工 | 矿工账户 |
| POST | `/api/mining/mine` | 执行挖矿 | 打包交易 |
| GET | `/api/blockchain/info` | 链信息 | 系统状态 |
| GET | `/api/blockchain/blocks` | 所有区块 | 完整链数据 |

## 3. 数据类型设计 (types.ts)

### 3.1 核心数据结构

```typescript
// 用户账户
interface User {
  address: string;      // 钱包地址（40位十六进制）
  privateKey: string;   // 私钥（64位十六进制）
  balance: number;      // 代币余额
  name?: string;        // 用户名（可选）
}

// 交易记录
interface Transaction {
  id: string;           // UUID 交易标识
  from: string;         // 发送方地址
  to: string;           // 接收方地址
  amount: number;       // 转账金额
  fee: number;          // 交易手续费
  timestamp: number;    // 时间戳
  signature?: string;   // 数字签名（预留）
  status: 'pending' | 'confirmed' | 'failed';
}

// 区块结构
interface Block {
  index: number;        // 区块索引（高度）
  timestamp: number;    // 创建时间戳
  transactions: Transaction[]; // 包含的交易
  previousHash: string; // 前一区块哈希
  hash: string;         // 当前区块哈希
  nonce: number;        // 工作量证明随机数
  miner: string;        // 矿工地址
  reward: number;       // 挖矿奖励
}
```

### 3.2 系统配置

```typescript
interface SystemConfig {
  blockReward: number;              // 挖矿奖励数量
  minFee: number;                   // 最小交易费
  difficulty: number;               // 挖矿难度级别
  maxTransactionsPerBlock: number;  // 区块最大交易数
}
```

## 4. 关键技术实现细节

### 4.1 地址生成算法
```typescript
createUser(name?: string): User {
  // 1. 生成32字节随机私钥
  const privateKey = crypto.randomBytes(32).toString('hex');
  
  // 2. 从私钥派生地址（简化版，真实区块链更复杂）
  const address = crypto.createHash('sha256')
                       .update(privateKey)
                       .digest('hex')
                       .substring(0, 40); // 取前40位作为地址

  const user: User = {
    address,
    privateKey,
    balance: 0,
    name: name || `User_${address.substring(0, 8)}`
  };

  this.users.set(address, user);
  return user;
}
```

### 4.2 交易历史查询
```typescript
getUserTransactionHistory(userAddress: string): Transaction[] {
  const allTransactions: Transaction[] = [];
  
  // 遍历所有区块收集相关交易
  for (const block of this.chain) {
    for (const tx of block.transactions) {
      if (tx.from === userAddress || tx.to === userAddress) {
        allTransactions.push(tx);
      }
    }
  }

  // 按时间倒序排列
  return allTransactions.sort((a, b) => b.timestamp - a.timestamp);
}
```

### 4.3 矿工奖励机制
```typescript
private rewardMiner(minerAddress: string, blockReward: number, transactions: Transaction[]): void {
  const miner = this.miners.get(minerAddress);
  const minerUser = this.users.get(minerAddress);

  if (!miner || !minerUser) return;

  // 计算总奖励 = 固定区块奖励 + 所有交易手续费
  const totalFees = transactions.reduce((sum, tx) => sum + tx.fee, 0);
  const totalReward = blockReward + totalFees;

  // 发放奖励并更新统计
  minerUser.balance += totalReward;
  miner.blocksMinedCount++;
  miner.totalRewards += totalReward;
}
```

## 5. 性能和安全考虑

### 5.1 性能优化
- **Map 数据结构**: O(1) 用户和矿工查找
- **数组操作**: 高效的区块链遍历
- **内存存储**: 无I/O瓶颈，适合演示

### 5.2 安全机制
- **余额验证**: 防止双重支付
- **哈希完整性**: 区块链不可篡改
- **输入验证**: API参数校验
- **工作量证明**: 防止恶意挖矿

### 5.3 扩展性设计
- **配置化参数**: 易于调整系统行为
- **模块化结构**: 便于功能扩展
- **类型安全**: TypeScript提供编译时检查